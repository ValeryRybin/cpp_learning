Лабораторная: subforwardlist
Вам нужно написать класс, который будет реализовывать односвязный список. Назовем его Subforwardlist, потому что он очень похож на forward_list из STL. В нем (как и в предыдущем subvector'е) не хватает "синтаксического сахара", который мы с вами будем осваивать и досыпать позде. Опять же, это то, что очень нужно хотя бы один раз в жизни сделать своими руками.

Здесь у вас больше шансов запутаться в указателях и потерять куски памяти, поэтому будьте внимательны. Если что-то идет не так или появляется неуверенность в том, сколько звездочек ставить - рисуйте схему. Если и со схемой непонятно - спрашивайте или разбирайтесь сами.

class Node {
    int data;
    Node* next;
};

class Subforwardlist {
private:
    Node* root;

public:
    ...
};

Полный список методов, который вам нужно реализовать:

Subforwardlist(); // конструктор 
void push_back(int d); // добавление элемента в конец недосписка
int pop_back(); // удаление элемента с конца недосписка, если пустой - возвращать 0
int push_forward(int d); // добавление элемента в начало недосписка
int pop_forward(); // удаление элемента из начала недосписка, если пустой - возвращать 0
void push_where(unsigned int where, int d); // добавление элемента с порядковым номером where		
int erase_where(unsigned int where); // удаление элемента с порядковым номером where, если пустой - возвращать 0
unsigned int size(); // определить размер недосписка
void clear(); // очистить содержимое недосписка
~Subforwardlist(); // деструктор

Вам нужно реализовать все эти методы и вписаться в профайлер - программу, которая проверяет корректность работы вашей программы. Это значит, что все методы должны быть реализованы, у них должны быть правильные интерфейсы (то есть заголовки - тип возвращаемого значения, название, список аргументов), они не должны терять данные и память. 